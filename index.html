<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sword Dungeon Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100%;
            max-width: 1024px;
            height: 100vh;
            background: #000;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(255, 100, 0, 0.3);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Dungeon World Themes */
        .dungeon-stone {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
        }

        .dungeon-fire {
            background: linear-gradient(180deg, #4a2a1a 0%, #2a1a0a 100%);
            box-shadow: inset 0 0 30px rgba(255, 100, 0, 0.2);
        }

        .dungeon-ice {
            background: linear-gradient(180deg, #1a3a4a 0%, #0a2a3a 100%);
            box-shadow: inset 0 0 30px rgba(100, 200, 255, 0.2);
        }

        .dungeon-shadow {
            background: linear-gradient(180deg, #1a1a2a 0%, #0a0a1a 100%);
            box-shadow: inset 0 0 30px rgba(100, 50, 150, 0.2);
        }

        .dungeon-nature {
            background: linear-gradient(180deg, #2a3a1a 0%, #1a2a0a 100%);
            box-shadow: inset 0 0 30px rgba(100, 150, 50, 0.2);
        }

        /* Virtual Joystick Styles */
        .joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(50, 50, 50, 0.7);
            border: 3px solid rgba(255, 100, 0, 0.5);
            border-radius: 50%;
            z-index: 100;
            touch-action: none;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5), 0 0 15px rgba(255, 100, 0, 0.3);
        }

        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(100, 100, 100, 0.3), rgba(20, 20, 20, 0.5));
        }

        .joystick-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 150, 50, 0.8), rgba(200, 80, 0, 0.8));
            border: 2px solid rgba(255, 100, 0, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255, 100, 0, 0.6), inset 0 0 5px rgba(0, 0, 0, 0.4);
            cursor: grab;
        }

        .joystick-stick:active {
            cursor: grabbing;
        }

        /* UI Styles */
        .ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid rgba(255, 100, 0, 0.6);
            border-radius: 8px;
            padding: 15px;
            z-index: 100;
            min-width: 250px;
            box-shadow: 0 0 20px rgba(255, 100, 0, 0.2);
        }

        .ui-section {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 100, 0, 0.3);
            padding-bottom: 10px;
        }

        .ui-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .ui-label {
            color: rgba(255, 150, 50, 0.8);
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .ui-value {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
        }

        .world-selector {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid rgba(255, 100, 0, 0.6);
            border-radius: 8px;
            padding: 10px;
            z-index: 100;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            width: 200px;
        }

        .world-btn {
            padding: 8px 12px;
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid rgba(255, 100, 0, 0.4);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .world-btn:hover {
            background: rgba(100, 100, 100, 0.8);
            border-color: rgba(255, 100, 0, 0.8);
            box-shadow: 0 0 10px rgba(255, 100, 0, 0.4);
        }

        .world-btn.active {
            background: rgba(255, 100, 0, 0.6);
            border-color: rgba(255, 100, 0, 1);
            box-shadow: 0 0 15px rgba(255, 100, 0, 0.6);
        }

        .help-text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 150, 50, 0.6);
            font-size: 12px;
            z-index: 100;
            max-width: 200px;
            line-height: 1.4;
        }

        /* Parallax backgrounds */
        .parallax-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            background-repeat: repeat-x;
            background-position: 0 0;
        }

        .parallax-far {
            opacity: 0.3;
            z-index: -1;
        }

        .parallax-mid {
            opacity: 0.5;
            z-index: -2;
        }

        .parallax-back {
            opacity: 0.2;
            z-index: -3;
        }

        /* Enemy and effects */
        .fps-counter {
            position: absolute;
            top: 20px;
            left: 150px;
            color: rgba(100, 255, 100, 0.8);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="game-container" id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="help-text">
            <strong>Controls:</strong><br>
            üïπÔ∏è Move: Joystick<br>
            Click: Attack<br>
            [1-5]: Change World<br>
            ESC: Pause
        </div>
        <div class="ui-panel">
            <div class="ui-section">
                <div class="ui-label">Current World</div>
                <div class="ui-value" id="worldName">Stone Dungeon</div>
            </div>
            <div class="ui-section">
                <div class="ui-label">Player HP</div>
                <div class="ui-value" id="playerHP">100/100</div>
            </div>
            <div class="ui-section">
                <div class="ui-label">Level</div>
                <div class="ui-value" id="playerLevel">1</div>
            </div>
            <div class="ui-section">
                <div class="ui-label">Enemies</div>
                <div class="ui-value" id="enemyCount">0</div>
            </div>
        </div>
        <div class="world-selector" id="worldSelector"></div>
        <div class="fps-counter" id="fpsCounter">FPS: 0</div>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 1024;
        const CANVAS_HEIGHT = 768;
        const TILE_SIZE = 32;

        // Dungeon World Definitions
        const DUNGEONS = {
            stone: {
                name: 'Stone Dungeon',
                id: 'stone',
                color: '#2a2a2a',
                accentColor: 'rgba(100, 100, 100, 0.8)',
                tileColor: '#3a3a3a',
                wallColor: '#1a1a1a',
                floorPattern: 'stone',
                parallaxColors: ['#1a1a1a', '#2a2a2a', '#3a3a3a'],
                enemyColor: '#ff6b6b',
                theme: 'dungeon-stone'
            },
            fire: {
                name: 'Fire Cavern',
                id: 'fire',
                color: '#4a2a1a',
                accentColor: 'rgba(255, 100, 50, 0.8)',
                tileColor: '#5a3a2a',
                wallColor: '#3a1a0a',
                floorPattern: 'lava',
                parallaxColors: ['#2a1a0a', '#4a2a1a', '#6a4a3a'],
                enemyColor: '#ff4500',
                theme: 'dungeon-fire'
            },
            ice: {
                name: 'Ice Cavern',
                id: 'ice',
                color: '#1a3a4a',
                accentColor: 'rgba(100, 200, 255, 0.8)',
                tileColor: '#2a4a5a',
                wallColor: '#0a2a3a',
                floorPattern: 'ice',
                parallaxColors: ['#0a2a3a', '#1a3a4a', '#2a4a5a'],
                enemyColor: '#00d4ff',
                theme: 'dungeon-ice'
            },
            shadow: {
                name: 'Shadow Realm',
                id: 'shadow',
                color: '#1a1a2a',
                accentColor: 'rgba(150, 100, 200, 0.8)',
                tileColor: '#2a2a3a',
                wallColor: '#0a0a1a',
                floorPattern: 'shadow',
                parallaxColors: ['#0a0a1a', '#1a1a2a', '#2a2a3a'],
                enemyColor: '#9d4edd',
                theme: 'dungeon-shadow'
            },
            nature: {
                name: 'Overgrown Temple',
                id: 'nature',
                color: '#2a3a1a',
                accentColor: 'rgba(100, 200, 50, 0.8)',
                tileColor: '#3a4a2a',
                wallColor: '#1a2a0a',
                floorPattern: 'moss',
                parallaxColors: ['#1a2a0a', '#2a3a1a', '#3a4a2a'],
                enemyColor: '#76d944',
                theme: 'dungeon-nature'
            }
        };

        // Game State
        const gameState = {
            canvas: null,
            ctx: null,
            currentDungeon: 'stone',
            player: {
                x: CANVAS_WIDTH / 2,
                y: CANVAS_HEIGHT / 2,
                width: 24,
                height: 32,
                hp: 100,
                maxHp: 100,
                level: 1,
                vx: 0,
                vy: 0,
                speed: 5,
                color: '#ffeb3b',
                attacking: false,
                attackCooldown: 0
            },
            enemies: [],
            particles: [],
            joystick: {
                x: 0,
                y: 0,
                active: false,
                baseX: 0,
                baseY: 0
            },
            keys: {},
            mouse: {
                x: 0,
                y: 0,
                down: false
            },
            camera: {
                x: 0,
                y: 0
            },
            parallaxOffset: 0,
            fps: 0,
            frameCount: 0,
            lastTime: Date.now()
        };

        // Initialize Game
        function init() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            // Set canvas size
            gameState.canvas.width = CANVAS_WIDTH;
            gameState.canvas.height = CANVAS_HEIGHT;

            // Initialize world selector buttons
            initWorldSelector();

            // Setup event listeners
            setupEventListeners();

            // Spawn initial enemies
            spawnEnemies(5);

            // Start game loop
            gameLoop();
        }

        function initWorldSelector() {
            const selector = document.getElementById('worldSelector');
            selector.innerHTML = '';
            
            Object.values(DUNGEONS).forEach(dungeon => {
                const btn = document.createElement('button');
                btn.className = 'world-btn';
                if (dungeon.id === gameState.currentDungeon) {
                    btn.classList.add('active');
                }
                btn.textContent = dungeon.id.charAt(0).toUpperCase() + dungeon.id.slice(1);
                btn.onclick = () => changeWorld(dungeon.id);
                selector.appendChild(btn);
            });
        }

        function changeWorld(dungeonId) {
            gameState.currentDungeon = dungeonId;
            gameState.parallaxOffset = 0;
            gameState.player.x = CANVAS_WIDTH / 2;
            gameState.player.y = CANVAS_HEIGHT / 2;
            gameState.enemies = [];
            spawnEnemies(5 + gameState.player.level * 2);
            
            // Update UI
            document.getElementById('worldName').textContent = DUNGEONS[dungeonId].name;
            
            // Update active button
            document.querySelectorAll('.world-btn').forEach((btn, idx) => {
                if (Object.values(DUNGEONS)[idx].id === dungeonId) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update container theme
            const container = document.getElementById('gameContainer');
            Object.values(DUNGEONS).forEach(d => {
                container.classList.remove(d.theme);
            });
            container.classList.add(DUNGEONS[dungeonId].theme);
        }

        function setupEventListeners() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.key] = true;
                
                if (e.key >= '1' && e.key <= '5') {
                    const dungeonArray = Object.values(DUNGEONS);
                    const index = parseInt(e.key) - 1;
                    if (index < dungeonArray.length) {
                        changeWorld(dungeonArray[index].id);
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                gameState.keys[e.key] = false;
            });

            // Mouse
            document.addEventListener('mousemove', (e) => {
                const rect = gameState.canvas.getBoundingClientRect();
                gameState.mouse.x = e.clientX - rect.left;
                gameState.mouse.y = e.clientY - rect.top;
            });

            document.addEventListener('mousedown', () => {
                gameState.mouse.down = true;
            });

            document.addEventListener('mouseup', () => {
                gameState.mouse.down = false;
            });

            // Joystick Touch Events
            const joystickContainer = document.querySelector('.joystick-container');
            const joystickStick = document.querySelector('.joystick-stick');

            joystickContainer.addEventListener('touchstart', handleJoystickStart);
            joystickContainer.addEventListener('touchmove', handleJoystickMove);
            joystickContainer.addEventListener('touchend', handleJoystickEnd);

            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            document.addEventListener('mousemove', handleJoystickMove);
            document.addEventListener('mouseup', handleJoystickEnd);
        }

        function handleJoystickStart(e) {
            const joystickContainer = document.querySelector('.joystick-container');
            const rect = joystickContainer.getBoundingClientRect();
            gameState.joystick.baseX = rect.left + rect.width / 2;
            gameState.joystick.baseY = rect.top + rect.height / 2;
            gameState.joystick.active = true;
            handleJoystickMove(e);
        }

        function handleJoystickMove(e) {
            if (!gameState.joystick.active) return;

            const touch = e.touches ? e.touches[0] : e;
            const dx = touch.clientX - gameState.joystick.baseX;
            const dy = touch.clientY - gameState.joystick.baseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 40;

            if (distance > maxDistance) {
                gameState.joystick.x = (dx / distance) * maxDistance;
                gameState.joystick.y = (dy / distance) * maxDistance;
            } else {
                gameState.joystick.x = dx;
                gameState.joystick.y = dy;
            }

            const stick = document.querySelector('.joystick-stick');
            if (stick) {
                stick.style.transform = `translate(calc(-50% + ${gameState.joystick.x}px), calc(-50% + ${gameState.joystick.y}px))`;
            }
        }

        function handleJoystickEnd() {
            gameState.joystick.active = false;
            gameState.joystick.x = 0;
            gameState.joystick.y = 0;
            
            const stick = document.querySelector('.joystick-stick');
            if (stick) {
                stick.style.transform = 'translate(-50%, -50%)';
            }
        }

        function spawnEnemies(count) {
            const dungeon = DUNGEONS[gameState.currentDungeon];
            for (let i = 0; i < count; i++) {
                gameState.enemies.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    width: 20,
                    height: 20,
                    hp: 30 + gameState.player.level * 5,
                    maxHp: 30 + gameState.player.level * 5,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    color: dungeon.enemyColor,
                    speed: 2 + gameState.player.level * 0.5
                });
            }
        }

        function update() {
            // Update player movement from joystick or keys
            const moveX = gameState.joystick.x || (gameState.keys['ArrowRight'] || gameState.keys['d'] ? 1 : (gameState.keys['ArrowLeft'] || gameState.keys['a'] ? -1 : 0));
            const moveY = gameState.joystick.y || (gameState.keys['ArrowDown'] || gameState.keys['s'] ? 1 : (gameState.keys['ArrowUp'] || gameState.keys['w'] ? -1 : 0));

            gameState.player.vx = moveX * gameState.player.speed;
            gameState.player.vy = moveY * gameState.player.speed;

            // Update player position
            gameState.player.x += gameState.player.vx;
            gameState.player.y += gameState.player.vy;

            // Boundary checking
            gameState.player.x = Math.max(0, Math.min(CANVAS_WIDTH - gameState.player.width, gameState.player.x));
            gameState.player.y = Math.max(0, Math.min(CANVAS_HEIGHT - gameState.player.height, gameState.player.y));

            // Update parallax
            gameState.parallaxOffset += gameState.player.vx * 0.05;

            // Update enemies
            gameState.enemies.forEach((enemy, index) => {
                // AI: Chase player
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }

                // Collision with player
                if (checkCollision(gameState.player, enemy)) {
                    gameState.player.hp -= 0.1;
                }

                // Remove dead enemies
                if (enemy.hp <= 0) {
                    gameState.enemies.splice(index, 1);
                    createParticles(enemy.x, enemy.y, 10);
                }
            });

            // Spawn new enemies when cleared
            if (gameState.enemies.length === 0) {
                spawnEnemies(5 + gameState.player.level * 2);
                gameState.player.level++;
                document.getElementById('playerLevel').textContent = gameState.player.level;
            }

            // Handle attacking
            if (gameState.mouse.down) {
                if (gameState.player.attackCooldown <= 0) {
                    const dx = gameState.mouse.x - gameState.player.x;
                    const dy = gameState.mouse.y - gameState.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    gameState.enemies.forEach(enemy => {
                        const edx = enemy.x - gameState.player.x;
                        const edy = enemy.y - gameState.player.y;
                        const edist = Math.sqrt(edx * edx + edy * edy);

                        if (edist < 60) {
                            enemy.hp -= 25;
                            createParticles(enemy.x, enemy.y, 5);
                        }
                    });

                    gameState.player.attackCooldown = 10;
                }
            }

            if (gameState.player.attackCooldown > 0) {
                gameState.player.attackCooldown--;
            }

            // Update particles
            gameState.particles = gameState.particles.filter(p => {
                p.life--;
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1; // Gravity
                return p.life > 0;
            });

            // Update UI
            document.getElementById('playerHP').textContent = Math.floor(gameState.player.hp) + '/' + gameState.player.maxHp;
            document.getElementById('enemyCount').textContent = gameState.enemies.length;

            // Game over check
            if (gameState.player.hp <= 0) {
                gameState.player.hp = gameState.player.maxHp;
                gameState.player.x = CANVAS_WIDTH / 2;
                gameState.player.y = CANVAS_HEIGHT / 2;
                gameState.player.level = 1;
                gameState.enemies = [];
                spawnEnemies(5);
            }

            // Update FPS
            gameState.frameCount++;
            const currentTime = Date.now();
            if (currentTime - gameState.lastTime >= 1000) {
                gameState.fps = gameState.frameCount;
                gameState.frameCount = 0;
                gameState.lastTime = currentTime;
                document.getElementById('fpsCounter').textContent = 'FPS: ' + gameState.fps;
            }
        }

        function draw() {
            const ctx = gameState.ctx;
            const dungeon = DUNGEONS[gameState.currentDungeon];

            // Clear canvas
            ctx.fillStyle = dungeon.color;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw parallax background layers
            drawParallaxLayers(ctx, dungeon);

            // Draw tilemap pattern
            drawTileMap(ctx, dungeon);

            // Draw enemies
            gameState.enemies.forEach(enemy => {
                // Enemy body
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);

                // Enemy outline
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);

                // Enemy HP bar
                const hpPercent = enemy.hp / enemy.maxHp;
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2 - 8, enemy.width, 4);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2 - 8, enemy.width * hpPercent, 4);
            });

            // Draw particles
            gameState.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1;
            });

            // Draw player
            ctx.fillStyle = gameState.player.color;
            ctx.fillRect(gameState.player.x - gameState.player.width / 2, gameState.player.y - gameState.player.height / 2, gameState.player.width, gameState.player.height);

            // Player outline
            ctx.strokeStyle = 'rgba(255, 255, 150, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(gameState.player.x - gameState.player.width / 2, gameState.player.y - gameState.player.height / 2, gameState.player.width, gameState.player.height);

            // Player HP bar
            const playerHpPercent = gameState.player.hp / gameState.player.maxHp;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.fillRect(gameState.player.x - gameState.player.width / 2, gameState.player.y - gameState.player.height / 2 - 12, gameState.player.width, 4);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.fillRect(gameState.player.x - gameState.player.width / 2, gameState.player.y - gameState.player.height / 2 - 12, gameState.player.width * playerHpPercent, 4);

            // Draw attack range indicator
            if (gameState.mouse.down) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(gameState.player.x, gameState.player.y, 60, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawParallaxLayers(ctx, dungeon) {
            const colors = dungeon.parallaxColors;
            
            // Far layer
            ctx.fillStyle = colors[0];
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 3; i++) {
                ctx.fillRect((i * CANVAS_WIDTH - gameState.parallaxOffset * 0.1) % CANVAS_WIDTH, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }

            // Mid layer
            ctx.fillStyle = colors[1];
            ctx.globalAlpha = 0.5;
            for (let i = 0; i < 3; i++) {
                ctx.fillRect((i * CANVAS_WIDTH - gameState.parallaxOffset * 0.2) % CANVAS_WIDTH, CANVAS_HEIGHT * 0.6, CANVAS_WIDTH, CANVAS_HEIGHT * 0.4);
            }

            ctx.globalAlpha = 1;
        }

        function drawTileMap(ctx, dungeon) {
            ctx.strokeStyle = dungeon.wallColor;
            ctx.lineWidth = 1;

            for (let x = 0; x < CANVAS_WIDTH; x += TILE_SIZE) {
                for (let y = 0; y < CANVAS_HEIGHT; y += TILE_SIZE) {
                    // Tile pattern based on dungeon type
                    const pattern = (x + y) % (TILE_SIZE * 2) === 0;
                    
                    if (pattern) {
                        ctx.fillStyle = dungeon.tileColor;
                        ctx.globalAlpha = 0.15;
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    }
                    
                    ctx.globalAlpha = 0.1;
                    ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }

            ctx.globalAlpha = 1;
        }

        function createParticles(x, y, count) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    color: DUNGEONS[gameState.currentDungeon].accentColor,
                    size: Math.random() * 4 + 2,
                    life: Math.random() * 20 + 10,
                    maxLife: Math.random() * 20 + 10
                });
            }
        }

        function checkCollision(rect1, rect2) {
            return rect1.x - rect1.width / 2 < rect2.x + rect2.width / 2 &&
                   rect1.x + rect1.width / 2 > rect2.x - rect2.width / 2 &&
                   rect1.y - rect1.height / 2 < rect2.y + rect2.height / 2 &&
                   rect1.y + rect1.height / 2 > rect2.y - rect2.height / 2;
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>